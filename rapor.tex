\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{afterpage}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\def\refname{Kaynakça}
\begin{document}

\title{Programlama Laboratuvarı I Proje III\\ Aile Ağacı Çizme Projesi}

\author{
\IEEEauthorblockN{\textbf{EREN ARAS}}
\IEEEauthorblockA{\textbf{Öğrenci No\\210201020}}
\and
\IEEEauthorblockN{\textbf{EMRE KAYA}}
\IEEEauthorblockA{\textbf{Öğrenci No\\210201029}}

}
\maketitle
\section{\textbf{ÖZET}}
Bu doküman  Kocaeli Üniversitesi 20022-2023 güz dönemi Mühendislik fakültesi Bilgisayar Mühendisliği Programlama Laboratuvarı 1 dersi Proje 3 için hazırlanmıştır. Rapor: Özet, Giriş, Yöntem, Deneysel Sonuçlar ve Katkılar alt başlıklarından oluşmaktadır.

\section{\textbf{GİRİŞ}}
    Proje : bütün temel tablolama işlemlerine sahip olan microsoft Excell teknolojisi kullanılarak oluşturulan ".csv, .xlsx" dosya formatında tablolamalarla oluşturulmuş bir aile verisinin okunması, okunan bu verinin Java programlama dilinin içerisinde bulunan \textbf{Apache POI, Apache Batik, Graphviz-Java} kütüphaneleri sayesinde Ağaç yapısı şeklinde görselleştirilmesi etrafında şekillenmektedir. \\

    Proje içerisindeki gereksinimlerin -Tree yapısı, depth first- gerçekleştirilmesi NYP konseptleri içermesi sebebiyle Java programlama dili tercih edilerek yazılmıştır. Java, tamamiyle NYP konseptlerini kullanan ve kendi sanal makinesi ile(Java Virtual Machine -JVM) tek bir kaynak kod ile evrensel bir şekilde farklı cihazlarda bytecode olarak okunduktan sonra çalışabilen bir programlama dilidir. Java'da her sınıf yapısı ayrı bir dosya içerisinde saklanır ve sonrasında bu sınıf dosyaları aracılığı ile oluşturulan nesneler bize gereken veriyi ve eylemi yapma seçeneği verir.\\

    Projenin Grafiksel kullanıcı arayüzü(GUI) geliştirilirken Javanın kütüphaneleri kütüphanesi olan \textbf{Swing,Apache Batik} ve \textbf{Graphviz-java} kullanılmıştır. Projenin giriş ekranı
    \textbf{JFrame, JButton} gibi basit swing yapıları ile oluşturulmuştur. Swing Layout'ları bir JAVA IDE'si olan Intellij ile hazırlanmıştır.\\
    
    Tüm bu işlemler yapılırken her bir adım proje klasörünün yanında bulunan log.txt dosyasına kaydedilir.
\section{\textbf{YÖNTEM}}\\
Projede kullanılan \textbf{Node, Person, GUI} gibi temel sınıflar haricindeki dosyalar çoğunlukla objeleri ve verileri manipüle etmek için kullanılan \textbf{Interface} dosyalarıdır. Kullanıcıdan alınan verinin alınması,okunması,işlenmesi ve GUI'a gönderilmesi işlemleri main fonksiyonu içinde açılmış ikinci bir \textbf{Thread} olan \textbf{Data Thread} içinde gerçekleşir.Interface dosyalarındaki fonksiyonların 
Projede kullanılan yöntemler 3 alt başlık halinde açıklanabilir:
\subsection{Kullanıcıdan alınan verinin okunması}
\begin{itemize}
    \item Proje temelde kullanıcıdan alınan \textbf{CSV} ya \textbf{XLSX} formatına sahip dosyaların okunması ile başlar.CSV ve XLSX dosyaları günümüzde ofis programlarında kullanılan ofis programlarına ait dosya formatlarıdır. CSV dosya formatı her bir satırdaki veriyi ayrı bir sütun olarak okuyabilir.CSV dosyalarında veriyi \textbf{virgül(,)} ile ayırarak bir sütun olarak ifade edebiliriz. XLSX dosya formatı ise günümüz Microsoft Office dosyalarında kullanılan varsayılan ofis dosyası formatıdır.
    \item 
    Proje ilk kullanıcıdan gelen veriyi okuyabilmek için \textbf{take\_data\_from\_folder\_root()} fonksiyonuyla bulunduğu konumdaki dosyaları tarama işlemi yapar. Bu fonksiyon eğer dosya sonu "csv" ise \textbf{Read\_CSV} fonksiyonunu, eğer sonu "xlsx" ise \textbf{read\_XLSX()} fonksiyonunu çağırır.\\
    \textbf{Read\_CSV}  fonksiyonu kullanıcıdan gelen CSV dosyasını virgüller ile tespit ederek hücreler şeklinde okur, sütunların isimlerini ifade eden ilk satırı keserek kendisine verilen String Arraylist'ine geri döndürür.\\
    \textbf{read\_XLSX()} de aynı kullanıcıdan gelen XLSX dosyasını okur. XLSX dosyası ham haliyle okunamayacağı için bu kısımda ofis dosyalarını istenildiği şekilde okumak için kullanılabilecek bir kütüphane olan \textbf{Apache POI} kullanılmıştır. Burada okunan veri de ilk satır atıldıktan sonra aynı şekilde verilen Arraylist'e hücreler olarak geri döner. İki fonksiyondan alından bütün veri \textbf{okunan\_itemler} isimli bir \textbf{String Arraylist} içinde birleşir ve işlenmek için farklı fonksiyonlara gönderilir.
\end{itemize}
\subsection{Kullanıcıdan alınan verinin sınıflandırılması ve işlenmesi}
\begin{enumerate}
    \item \textbf{İlk Atama Operasyonları:}\\Kullanıcıdan gelen veriler ham halde bir String Arraylist'ine atanır. Atanan bu veriler \textbf{create\_Nodes} ve \textbf{create\_Person\_from\_Data} fonksiyonları kullanılarak önce bir \textbf{Node} nesnesine, sonrasında da yaratılan Node nesnesinin tuttuğu \textbf{Person} yani kişi nesnesine atanır. Okunan bütün veriler Person nesnesinde tutulurken Node nesnesi ağacın çizilmesini sağlayan bir üst sınıf görevi görür.
    \item \textbf{Yaş Hesaplama:}\\ Node'un içindeki Person sınıfının içinden \textbf{doğum tarihi} verisi çekilerek \textbf{calculate\_age} fonksiyonuna gönderilir. Bu fonksiyon her bir Node için güncel tarihi kullanarak bir yaş ataması yapar.
    \item \textbf{Anne,Baba ve Çocuk Tespiti ve Ataması} :\\
    xlsx veya csv dosyasından düzenli bir biçimde okunan veriler birbirine herhangi bir ilişkisi olmadan bir Arraylist e atıldıktan sonra bu arraylist
    \textbf{Create\_Relations()} fonksiyonuna parametre olarak yollanır. bu fonksiyon da kendi içerisinde 3 adet fonksiyon çağırır bunlar : 
    \begin{itemize}
    \item \textbf{cocuk\_Kontrol()}
    \item \textbf{baba\_Kontrol()}
    \item \textbf{anne\_Kontrol()}
    \end{itemize}
    Fonksiyon iç içe 2 for döngüsünden oluşur ve kontrol kısmında bu iki for döngüsünden gelen iki adet \textbf{Node} verisi vardır bunlardan birisi kontrol edilen diğeri ise ana \textbf{Node} dur.\\ Fonksiyonun temel işlevi ana \textbf{Node}'un \textbf{annesini} \textbf{babasını} ve \textbf{çucuğunu} bulmaktır.\\ Anne ve baba bulunması için öncelikle alt fonksiyonların gereksinimleri olan, Node un anne ve baba ile ilişkilerinin olduğu soy isimleri tespit eder. bunun için ana kişinin kızlık soy adı varsa kişi kız ve evlidir bu yüzden anne ve babasını bulmak için \textbf{Kızlık Soyadı} kullanılmalıdır.\\ Çocuk tespiti için kontrol Node'un Node ile ilişkilerinin olduğu soy isimini tespit eder, kişisinin kızlık soy adı varsa kişi kız ve evlidir bu yüzden Node un çocuğunu bulmak için \textbf{Kızlık Soyadı} kullanır.\\
    fonksiyonlarda kullanılacak soy isimler bulunduktan sonra ayrı ayrı fonksiyonlara gönderilir. \textbf{cocuk\_Kontrol()} fonksiyonu : daha önce eklenmiş mi kotrolü için ana Node kişisinin çocuklarının \textbf{ID}si ile kontrol nodeunun \textbf{ID}sini karşılaştırır, eğer eşleşme bulunamadıysa \textbf{Node}'un çocukları listesine ekleme yapar.\\
    \textbf{anne\_Kontrol()} fonksiyonu : eğer, Kontrol Node'unun adı; ana Node'un anne adı ile aynı ise, fonksiyona gelen ilgili kontrol soy isimleri aynı ise, anne adayı olan kontrol Node'un eşinin adı ile ana Node'un baba adı aynı ise; ana Node'a anne ataması yapılır.
    \textbf{baba\_Kontrol()} fonksiyonu : eğer, Kontrol Node'unun adı; ana Node'un baba adı ile aynı ise, fonksiyona gelen ilgili kontrol soy isimleri aynı ise, baba adayı olan kontrol Node'un eşinin adı ile ana Node'un anne adı aynı ise; ana Node'a anne ataması yapılır.
    % matematiksel fonksiyonu $$ ile kullan. - okkey
    bu fonksiyonun zaman karmaşıklığı : \textbf{$O(n^2)$} dir.

    \item
\end{enumerate}

    

\subsection{Kullanıcıdan alınan verinin Ağaca dönüştürülmesi}

Kullanıcıdan alınan veri bir ağaca dönüştürülürken birden fazla aşamadan geçirilir.  Program GUI için birden fazla kütüphane ve sistem kullanarak çalışır. Bu kısımlar şu şekilde sınıflandırılabilir:\\\\\\
\begin{enumerate}
    \item \textbf{Sınıflandırılmış veriden Graph Kütüphanesi Yardımıyla Ağacın Çizilmesi}\\
    Program temelde Java içerisinde bulunan  \textbf{Swing} kütüphanesi ile pencere ve butonlar gibi basit bileşenleri ekrana kolaylıkla çizer. Ama Swing kütüphanesi elde edilen veriden okunaklı ve detaylı bir aile ağacı çizmek için efektif ve hızlı bir GUI bileşenine sahip değildir. Bu Noktada \textbf{Graphviz-java} kütüphanesi kullanılmıştır. \textbf{Graphviz} verilen verilerin kullanıcının istediği şekilde \textbf{SVG(Resim dosyası)} formatında çıktı olarak alabileceği bir \textbf{Graph} kütüphanesidir.\\\\ Graph'lar temelde düğümler ve birbirine bağlanan kenarlardan oluşur. Projede istenen aile ağacından tek farkları ise bir \textbf{Kök} düğüm içermeleridir. Bu yüzden de graph çizmek için tasarlanmış bir araçla kolaylıkla bir aile ağacı çizilebilir.Bu projede ise Graphviz'in java implementasyonu denilebilecek \textbf{Graphviz-java} kütüphanesi kullanılmıştır. Bu kütüphane temelde graph'ların çizilmesi için gereken komutları özel bir dosya formatından(\textbf{ağaç.dot dosyası}) alır.Ama ağacın \textbf{Kök} düğüm kullanılarak sıralı bir şekilde çizilmesi ise kütüphanenin buna tam olarak bir desteğinin olmaması sebebiyle bizim tarafımızca verilen veriyle aile ağacı çizen bir \textbf{.dot } dosyası yaratıp bunu okuyabilecek bir \textbf{Interface} olarak  yazılmıştır.\\
    \begin{enumerate}
        \item \textbf{Dot Dosyasının yaratılması}\\
        \textbf{Dot\_File\_Operator} isimli interface dosyası \textbf{draw\_tree} fonksiyonuyla başlar. Bu fonksiyon çağırıldığı ve veri işlemek için özel olan \textbf{Data Thread'inde} \textbf{annesi ve babası olmayan} yani \textbf{Kök} denilebilecek kişilerin olduğu bir Arrraylist'i parametre olarak alır. Bu fonksiyon ilk önce \textbf{create\_Dot\_Node} fonksiyonunu çağırır. Bu fonksiyon verilen kişiyi ekrana çizmek için tanımlar. Sonrasında kişinin eşi ve kendisi arasında küçük bir \textbf{dot(nokta)} yaratır. Bu nokta 2 kişiden çizilecek çocukları ifade etmek için kullanılır.
        \includegraphics[scale=0.5]{dot.png}
        Dot yaratıldıktan sonra node'un kendisinden bir eş düğümü yaratılır. Bunun için kullanılan fonksiyon \textbf{create\_partnership} fonksiyonudur ve temelde kişi, eşi ve dot arasında bağlantı kurar. Sonrasında ise draw\_tree fonksiyonu kişinin çocuklarının kontrolünü yapar. Eğer kişinin çocukları varsa onları da ekranda çizilmek üzere tanımlar ve \textbf{dot}'u kullanarak annesi ve babasına ekler. Eğer Kök düğümün çocuklarının çocukları da varsa fonksiyon \textbf{recursive} yani özyinelemeli bir şekilde kendisin çocuğunu kullanarak çağırır.\\
        \item \textbf{Dot Dosyasının Çıktısının Alınması}\\
        Interface kullanılarak yazılan dot dosyası yine aynı interface içindeki \textbf{convert\_dot\_file\_to\_SVG} fonksiyonu kullanılarak \textbf{SVG} formatında bir resim dosyasına dönüştürür. Bunun için ise kütüphane kendi içerisinde bir V8 yani bir javascript motorunu hiçbir javascript kodu olmadan binding yöntemiyle kullanır. Elde edilen 10000x5000 çözünürlüğündeki svg dosyası sonrasında ekrana çizilmek için kullanılacaktır.
    \end{enumerate}
    \item \textbf{Çizilen Ağacın Java Swing GUI'a Aktarılması}\\
    Çizilen ağacın SVG yani resim formatında yaratılması kendi başına yeterli değildir. Bu noktada Java Swing kütüphanesi kullanılır. Swing kütüphanesi ilk aşamada ekrana 2 farklı ağacı gösterebilmek için 2 butona sahip bir menü çalıştırır.\\\\
    \includegraphics[scale=0.5]{menu.png}\\
    Bu menüden itibaren iki farklı ağaç ekrana çizilir.
    \begin{enumerate}
        \item \textbf{Ana Ağacın Çizilmesi}\\
        Önceki kısımlarda anlatılan işlemlerle elde edilen \textbf{SVG} formatındaki resim dosyası burada \textbf{Apache Batik} isimli bir kütüphane ile ekrana basılır. \textbf{Apache Batik}, java'da swing gibi GUI'larda kullanabileceğimiz basit bir  resim dosyası okuma işlemini yapan kütüphanedir. Swing içerisinde yazdığımız kodla bir \textbf{JPanel} objesi gibi çalışır ve kullanıcıdan alınan dosya yolundaki resim dosyasını bizim oluşturduğumuz Swing \textbf{JFrame} nesnesi içerisinde bir \textbf{JPanel} nesnesi olarak ekrana çizer. Burada kütüphanenin sahip olduğu ve bizim kendisi yazdığımız bazı metodlar sayesinde ekrana çizilen resime istenildiği gibi fare tekerleği kullanılarak büyütme ve küçültme yapılabilir, \textbf{CTRL} tuşu kullanılarak istenilen bölgeye geçiş yapılabilir ya da \textbf{ESC} tuşu ile ağaca yukarıdan ve daha geniş bir açıyla bakılabilir.
        \includegraphics[scale=0.4]{agac.png}\\\\
        \includegraphics[scale=0.4]{agac_zoom.png}
        \item \textbf{Yaş Ağacının Çizilmesi}\\
        Yaşa göre sıralama yapan fonksiyondan gelen Node(Düğüm) nesnelerinin sıralaması bu noktada yapılır. Ana ağacın çizilmesi için gereken bütün kütüphaneler burada da kullanılmıştır. Ana ağaçtan tek fark anne yada baba düğüm olmadığı için buradaki düğüm bağlantılarının çizilmesi için dikey sıralama yapılmıştır.\\
        \includegraphics[scale=0.5]{yas.png}
    \end{enumerate}  
\end{enumerate}

\section{\textbf{İsterler}}
\begin{enumerate}
    \itemÇocuğu olmayan düğümlerin listesi yaş sıralamasına göre kaydedilmesi işleminde : \textbf{depth\_first\_age()} fonksiyonu kullanılmıştır, fonksiyon parametre olarak Depth first algoritması gereği \textbf{Kök} Node'unu ve içerisini doldurup geri döndürmek için sıralanmışçocuklar \textbf{Arraylist}'i alır. Fonksiyon Kök Node'undan başlayarak öncelikle çocuklar listesinin kontrolünü yapar eğer liste boş değil ise; fonksiyonu her bir çocuk için tekrar çağırır. eğer Kök Node'un çocuklar listesi boş ise, ekleme adımına geçilir. Ekleme adımında, daha önce ekleme yapılmamışsa direkt eklenir. eğer ekleme yapıldıysa boyut karşılaştırılması yapılır ve kişi listedeki kendisinden küçük en büyük yaştaki kişinin yanına eklenir. Tüm bu işlemler adım adım \textbf{Log.txt} dosyasına kaydedilir.
    bu fonksiyonun zaman karmaşıklığı : \textbf{$O(V+E)$} dir, V Node sayısı, E Çocuk sayısı.
    \item Soy ağacında aynı isme sahip kişilerin ismi ve yaşları \textbf{same\_name()} fonksiyonu ile tespit edilip log dosyasında gösterilmiştir.\\
    bu fonksiyonun zaman karmaşıklığı : \textbf{$O(n^2)$} dir.
    \item Soy ağacının kaç nesilden oluştuğu \textbf{find\_max\_depth} fonksiyonu ile bulunmuştur ve log dosyasında gösterilmiştir. (Ağacın maksimum derinliği.)
    bu fonksiyonun zaman karmaşıklığı : her node a bir kez gidileceğinden \textbf{$O(n)$} dir.
    \item Kan grubu A olanların listesi kaydedilerek \textbf{find\_by\_blood()} fonksiyonu sayesinde gösterilmiştir.
    bu fonksiyonun zaman karmaşıklığı : \textbf{$O(n)$} dir.
    \item Soyunda aynı mesleği yapan çocuklar veya torunlar log dosyasına kayıt edilmiştir.
    bu fonksiyonun zaman karmaşıklığı : \textbf{$O(n^2)$} dir.
    
\end{enumerate}

\section{\textbf{DENEYSEL SONUÇLAR}}
    Projede csv ya xlsx dosyasından öncesinde bir Node(Düğüm) ve onun içinde de bir Person(Kişi) nesnesine aktarılabileceği ve bu şekilde bir aile ağacının düzenli biçimde okunabileceği anlaşılmıştır. Bunun yanı sıra tablo biçiminden okunan veriyi tablo biçminde kullanmak yerine Encapsulation, Inheritance, Polymorphism, Abstraction gibi nesne yönelimli programlama konseptleri ile birlikte bir graph kütüphanesiyle birlikte gerektiğinde eklemeler yapılarak bir aile ağacı yapısı oluşturulabileceği sonucuna varılmıştır. Aynı zamanda bu veriyi Ağaç yapısında oluşturma sonucunda elde edilen aile bağlarının ve  bir kök noktasından diğer her noktaya erişebilme gibi başlıkların yapılabileceği açığa çıkartılmıştır.



\begin{thebibliography}{}
https://graphviz.org/\\
https://github.com/nidi3/graphviz-java\\
https://poi.apache.org/\\
https://xmlgraphics.apache.org/batik/\\
https://www.javatpoint.com/apache-poi-tutorial\\
https://www.javatpoint.com/java-swing\\
https://www.javatpoint.com/interface-in-java\\
https://www.javatpoint.com/multithreading-in-java\\
\end{thebibliography}


\end{document}